<?php

namespace Drupal\Tests\next_path_alias\Kernel;

use Drupal\Core\Field\FieldStorageDefinitionInterface;
use Drupal\field\Entity\FieldConfig;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\KernelTests\KernelTestBase;
use Drupal\next\Entity\NextSite;
use Drupal\next_path_alias\Plugin\Validation\Constraint\NextPathAliasConstraint;
use Drupal\node\Entity\Node;
use Drupal\node\Entity\NodeType;
use Drupal\node\NodeInterface;
use Drupal\path_alias\Entity\PathAlias;
use Drupal\path_alias\PathAliasInterface;
use Drupal\Tests\pathauto\Functional\PathautoTestHelperTrait;
use Drupal\Tests\RandomGeneratorTrait;
use Drupal\Tests\Traits\Core\PathAliasTestTrait;
use Drupal\user\Entity\User;

/**
 * Test description.
 *
 * @group next_path_alias
 */
class PathAliasUniquePerSite extends KernelTestBase {

  use PathAliasTestTrait;
  use PathautoTestHelperTrait;
  use RandomGeneratorTrait;

  /**
   * {@inheritdoc}
   */
  protected static $modules = [
    'system',
    'node',
    'user',
    'field',
    'path',
    'path_alias',
    'pathauto',
    'token',
    'next_path_alias',
    'next',
  ];

  /**
   * The module handler service.
   *
   * @var \Drupal\Core\Extension\ModuleHandlerInterface
   */
  protected $moduleHandler;

  /**
   * The path alias repository service.
   *
   * @var \Drupal\path_alias\AliasRepositoryInterface
   */
  protected $aliasRepository;

  /**
   * A random title for created nodes.
   *
   * @var string
   */
  protected $randomTitle;

  /**
   * {@inheritdoc}
   */
  protected function setUp(): void {
    parent::setUp();

    // Add needed services.
    $this->aliasRepository = $this->container->get('path_alias.repository');
    $this->moduleHandler = $this->container->get('module_handler');

    // Install all necessary schemas and configs.
    $this->installEntitySchema('user');
    $this->installEntitySchema('node');
    $this->installSchema('node', ['node_access']);
    $this->installEntitySchema('path_alias');
    $this->installConfig(['system', 'pathauto']);

    // Workaround for https://www.drupal.org/project/drupal/issues/3056234
    User::create([
      'name' => '',
      'uid' => 0,
    ])->save();

    // Hook install required.
    $this->moduleHandler->loadInclude('next_path_alias', 'install');
    $this->moduleHandler->invoke('next_path_alias', 'install');

    // Create page content type with a "sites" field.
    $node_type = NodeType::create(['type' => 'page', 'name' => 'Page']);
    $node_type->save();

    // Create a "field_sites" field and attach to the page content type.
    FieldStorageConfig::create([
      'field_name' => 'field_sites',
      'type' => 'entity_reference',
      'settings' => [
        'target_type' => 'next_site',
      ],
      'entity_type' => 'node',
      'cardinality' => FieldStorageDefinitionInterface::CARDINALITY_UNLIMITED,
    ])->save();
    FieldConfig::create([
      'field_name' => 'field_sites',
      'entity_type' => 'node',
      'bundle' => 'page',
    ])->save();

    // Set as sites field in Next Path Alias configuration.
    $this->config('next_path_alias.settings')
      ->set('sites_field_name', 'field_sites')
      ->save();

    // Create Next.js sites.
    $this->createNextSite('site_1');
    $this->createNextSite('site_2');

    // Node title to be used.
    $this->randomTitle = $this->randomString(100);
  }

  /**
   * Test path alias uniqueness when path alias generated by pathauto.
   *
   * Pathauto takes care of not having the same alias on the same site.
   */
  public function testPathAliasUniquenessWhenPathauto() {

    // Create a pathauto pattern.
    $this->createPattern('node', '[node:title]');

    // Create a node in site1.
    $node_site_1 = $this->createNodeOnSite('site_1');

    // Create a second equal node in site1.
    $second_node_site_1 = $this->createNodeOnSite('site_1');

    // Create a third equal node in site2.
    $node_site_2 = $this->createNodeOnSite('site_2');

    // Unregister next shutdown events as they hide test errors when test fails.
    $this->unregisterNextShutdownFunctions();

    // Different sites, same alias allowed.
    $this->assertEquals($this->getNodeAlias($node_site_1), $this->getNodeAlias($node_site_2));

    // Same sites, same alias not allowed.
    $this->assertNotEquals($this->getNodeAlias($node_site_1), $this->getNodeAlias($second_node_site_1));

    // Alias differs in suffix.
    $this->assertEquals($this->getNodeAlias($node_site_1) . '-0', $this->getNodeAlias($second_node_site_1));
  }

  /**
   * Test path alias validations when path alias is set manually.
   *
   * Pathauto does not take care of not having the same alias on the same site
   * so aliases are generated, we test those alias are valid.
   * (do not exist same alias in the same site).
   */
  public function testPathAliasValidationManualPath() {
    $random_alias = '/' . $this->randomMachineName(24);

    // Create a node in site1.
    $node_site_1 = $this->createNodeOnSite('site_1', $random_alias);

    // Create a second equal node in site1.
    $second_node_site_1 = $this->createNodeOnSite('site_1', $random_alias);

    // Create a third equal node in site2.
    $node_site_2 = $this->createNodeOnSite('site_2', $random_alias);

    // Unregister next shutdown events as they hide test errors when test fails.
    $this->unregisterNextShutdownFunctions();

    // Validate all generated aliases are equal.
    $this->assertEquals($random_alias, $this->getNodeAlias($node_site_2));
    $this->assertEquals($random_alias, $this->getNodeAlias($second_node_site_1));
    $this->assertEquals($random_alias, $this->getNodeAlias($second_node_site_1));

    // Validate the generated path alias for each site.
    $this->assertFalse($this->nodePathAliasHasUniquenessViolation($node_site_1));
    $this->assertTrue($this->nodePathAliasHasUniquenessViolation($second_node_site_1));
    $this->assertFalse($this->nodePathAliasHasUniquenessViolation($node_site_2));

    // Test node update.
    $node_site_2->set('field_sites', [
      ['target_id' => 'site_1'],
    ])->save();
    $this->unregisterNextShutdownFunctions();

    $this->assertTrue($this->nodePathAliasHasUniquenessViolation($node_site_2));
    $path_alias = $this->getFullNodeAliasEntity($node_site_2);
    $this->assertEquals('site_1', $path_alias->get('next_sites')->getValue()[0]['value']);
  }

  /**
   * Test path alias on node update.
   */
  public function testPathAliasOnNodeUpdateWhenPathauto() {

    // Create a pathauto pattern.
    $this->createPattern('node', '[node:title]');

    // Create a node in site1.
    $node_site_1 = $this->createNodeOnSite('site_1');

    // Create a node in site2.
    $node_site_2 = $this->createNodeOnSite('site_2');

    // Update node in site2 to site1, keep title.
    $node_site_2->set('field_sites', [
      ['target_id' => 'site_1'],
    ])->save();
    $this->unregisterNextShutdownFunctions();

    $this->assertNotEquals($this->getNodeAlias($node_site_1), $this->getNodeAlias($node_site_2));
    $path_alias = $this->getFullNodeAliasEntity($node_site_2);
    $this->assertEquals('site_1', $path_alias->get('next_sites')->getValue()[0]['value']);

    // Try again without title overlap.
    $node_site_2->setTitle('New title')->set('field_sites', [
      ['target_id' => 'site_2'],
    ])->save();
    $node_site_2->set('field_sites', [
      ['target_id' => 'site_1'],
    ])->save();
    $this->unregisterNextShutdownFunctions();

    $path_alias = $this->getFullNodeAliasEntity($node_site_2);
    $this->assertEquals('site_1', $path_alias->get('next_sites')->getValue()[0]['value']);
  }

  /**
   * Create and save a Next.js site entity.
   *
   * @param string $identifier
   *   Name and identifier of the site.
   */
  protected function createNextSite(string $identifier): void {
    NextSite::create([
      'id' => $identifier,
      'label' => $identifier,
    ])->save();
  }

  /**
   * Create a node with the parameters passed.
   *
   * @param string $site
   *   The site.
   * @param string|null $alias
   *   The alias.
   *
   * @return \Drupal\node\NodeInterface
   *   The created node.
   */
  protected function createNodeOnSite(string $site, string $alias = NULL): NodeInterface {
    $values = [
      'title' => $this->randomTitle,
      'type' => 'page',
      'status' => TRUE,
      'field_sites' => [
        ['target_id' => $site],
      ],
    ];

    if (!is_null($alias)) {
      $values['path'] = $alias;
    }

    $node = Node::create($values);
    $node->save();

    return $node;
  }

  /**
   * Helper function that retrieves path alias for a specific node.
   *
   * @param \Drupal\node\NodeInterface $node
   *   The node.
   *
   * @return string
   *   The alias.
   */
  protected function getNodeAlias(NodeInterface $node): ?string {
    $path_alias = $this->aliasRepository->lookupBySystemPath('/' . $node->toUrl()->getInternalPath(), 'en');
    return $path_alias ? $path_alias['alias'] : NULL;
  }

  /**
   * Returns the full path alias entity for a node.
   *
   * @param \Drupal\node\NodeInterface $node
   *   The node to retrieve the full path alias entity.
   *
   * @return \Drupal\path_alias\PathAliasInterface|null
   *   The full path alias entity.
   */
  protected function getFullNodeAliasEntity(NodeInterface $node): ?PathAliasInterface {
    $entity_ids = \Drupal::entityTypeManager()->getStorage('path_alias')->getQuery()
      ->accessCheck(FALSE)
      ->condition('path', '/node/' . $node->id())
      ->execute();
    return PathAlias::load(reset($entity_ids));
  }

  /**
   * Checks if passed node path alias has uniqueness violation.
   *
   * @param \Drupal\node\NodeInterface $node
   *   The node to check.
   *
   * @return bool
   *   Whether the node path alias has uniqueness violation or not.
   */
  protected function nodePathAliasHasUniquenessViolation(NodeInterface $node): bool {
    $violations = PathAlias::load($node->get('path')->pid)->validate();

    foreach ($violations as $violation) {
      if ($violation->getConstraint() instanceof NextPathAliasConstraint) {
        return TRUE;
      }
    }

    return FALSE;
  }

  /**
   * Unregister next shutdown events.
   *
   * It's advisable to call this method after all entities have been created
   * in the test. Otherwise, when a test fails the message is not visible due
   * to container not being available.
   */
  protected function unregisterNextShutdownFunctions() {
    $list = &drupal_register_shutdown_function();
    foreach ($list as $key => $item) {
      if ($item['callback'] == '_next_dispatch_entity_action_event') {
        unset($list[$key]);
      }
    }
  }

}
